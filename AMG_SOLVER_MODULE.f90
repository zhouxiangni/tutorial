


MODULE AMG_SOLVER_MODULE
  USE SPARSE_MATRIX_MODULE

  IMPLICIT NONE

  PRIVATE

  integer, private, parameter :: dp = kind(1.d0)


  PUBLIC::AMG_SOLVER_INITIALIZE, &
       AMG_SOLVER_DESTROY, &
       AMG_SOLVER_SOLVE

  PRIVATE:: AMG_SOLVER_SET_PATTERN, &
       AMG_SOLVER_SET_MATRIX, &
       AMG_SOLVER_PROJECTION, &
       AMG_SOLVER_GAUSS_ELIMINATION


  ! Used to implement pointer array. Only a small trick, ;-)
  TYPE, PRIVATE::SPARSITY_PATTERN_POINTER
     TYPE(SPARSITY_PATTERN), POINTER::PTR=>NULL()
  END TYPE SPARSITY_PATTERN_POINTER

  TYPE, PRIVATE::SPARSE_MATRIX_POINTER
     TYPE(SPARSE_MATRIX), POINTER::PTR=>NULL()
  END TYPE SPARSE_MATRIX_POINTER

  TYPE, PRIVATE::VECTOR_POINTER
     REAL(dp), DIMENSION(:), POINTER::PTR=>NULL()
  END TYPE VECTOR_POINTER

  ! declaration of structure AMG_SOLVER.
  TYPE, PUBLIC::AMG_SOLVER
     INTEGER::N_MAX_PROJECT_COUNT
     TYPE(SPARSITY_PATTERN), POINTER::PATTERN=>NULL()
     TYPE(SPARSE_MATRIX), POINTER::MATRIX=>NULL()
     INTEGER::N_PROJECT_COUNT
     REAL(dp)::TOLERANCE
     INTEGER::N_BEFORE_SMOOTH_STEP
     INTEGER::N_AFTER_SMOOTH_STEP
     TYPE(SPARSITY_PATTERN_POINTER), DIMENSION(:), POINTER::LEFT_PROJECT_PATTERN=>NULL()
     TYPE(SPARSITY_PATTERN_POINTER), DIMENSION(:), POINTER::RIGHT_PROJECT_PATTERN=>NULL()
     TYPE(SPARSITY_PATTERN_POINTER), DIMENSION(:), POINTER::PROJECTED_PATTERN=>NULL()
     TYPE(SPARSE_MATRIX_POINTER), DIMENSION(:), POINTER::LEFT_PROJECT_MATRIX=>NULL()
     TYPE(SPARSE_MATRIX_POINTER), DIMENSION(:), POINTER::RIGHT_PROJECT_MATRIX=>NULL()
     TYPE(SPARSE_MATRIX_POINTER), DIMENSION(:), POINTER::PROJECTED_MATRIX=>NULL()
     TYPE(VECTOR_POINTER), DIMENSION(:), POINTER::PROJECTED_SOLUTION=>NULL()
     TYPE(VECTOR_POINTER), DIMENSION(:), POINTER::PROJECTED_RESIDUAL=>NULL()
     INTEGER::MAX_PROJECTED_MATRIX_TYPE
     REAL(dp), DIMENSION(:,:), POINTER::MAX_PROJECTED_MATRIX=>NULL()
  END TYPE AMG_SOLVER

CONTAINS

  ! initialize the solver: allocating memory, preapre project matrix
  SUBROUTINE AMG_SOLVER_INITIALIZE(SOLVER, MATRIX)
    TYPE(AMG_SOLVER), INTENT(INOUT)::SOLVER
    TYPE(SPARSE_MATRIX), INTENT(IN)::MATRIX

    INTEGER::I
    SOLVER%N_MAX_PROJECT_COUNT = 20
    SOLVER%TOLERANCE = 1.0E-16
    SOLVER%N_BEFORE_SMOOTH_STEP = 5
    SOLVER%N_AFTER_SMOOTH_STEP = 5
    ALLOCATE(SOLVER%LEFT_PROJECT_PATTERN(1:SOLVER%N_MAX_PROJECT_COUNT-1))
    ALLOCATE(SOLVER%RIGHT_PROJECT_PATTERN(1:SOLVER%N_MAX_PROJECT_COUNT-1))
    ALLOCATE(SOLVER%PROJECTED_PATTERN(1:SOLVER%N_MAX_PROJECT_COUNT))
    ALLOCATE(SOLVER%LEFT_PROJECT_MATRIX(1:SOLVER%N_MAX_PROJECT_COUNT-1))
    ALLOCATE(SOLVER%RIGHT_PROJECT_MATRIX(1:SOLVER%N_MAX_PROJECT_COUNT-1))
    ALLOCATE(SOLVER%PROJECTED_MATRIX(1:SOLVER%N_MAX_PROJECT_COUNT))
    ALLOCATE(SOLVER%PROJECTED_SOLUTION(1:SOLVER%N_MAX_PROJECT_COUNT))
    ALLOCATE(SOLVER%PROJECTED_RESIDUAL(1:SOLVER%N_MAX_PROJECT_COUNT))
    ALLOCATE(SOLVER%PROJECTED_PATTERN(1)%PTR)
    NULLIFY(SOLVER%PROJECTED_PATTERN(1)%PTR%ROW_START)
    NULLIFY(SOLVER%PROJECTED_PATTERN(1)%PTR%COLUMN_INDEX)
    ALLOCATE(SOLVER%PROJECTED_MATRIX(1)%PTR)
    NULLIFY(SOLVER%PROJECTED_MATRIX(1)%PTR%MATRIX_ENTRY)
    NULLIFY(SOLVER%PROJECTED_SOLUTION(1)%PTR)
    NULLIFY(SOLVER%PROJECTED_RESIDUAL(1)%PTR)
    DO I=1,SOLVER%N_MAX_PROJECT_COUNT-1
       CALL SPARSITY_PATTERN_ALLOCATE(SOLVER%LEFT_PROJECT_PATTERN(I)%PTR)
       CALL SPARSITY_PATTERN_ALLOCATE(SOLVER%RIGHT_PROJECT_PATTERN(I)%PTR)
       CALL SPARSITY_PATTERN_ALLOCATE(SOLVER%PROJECTED_PATTERN(I+1)%PTR)
       CALL SPARSE_MATRIX_ALLOCATE(SOLVER%LEFT_PROJECT_MATRIX(I)%PTR)
       CALL SPARSE_MATRIX_ALLOCATE(SOLVER%RIGHT_PROJECT_MATRIX(I)%PTR)
       CALL SPARSE_MATRIX_ALLOCATE(SOLVER%PROJECTED_MATRIX(I+1)%PTR)
       NULLIFY(SOLVER%PROJECTED_SOLUTION(I+1)%PTR)
       NULLIFY(SOLVER%PROJECTED_RESIDUAL(I+1)%PTR)
    END DO
    NULLIFY(SOLVER%MAX_PROJECTED_MATRIX)
    CALL AMG_SOLVER_SET_MATRIX(SOLVER, MATRIX)
    !WRITE (*,*) "AMG_SOLVER_INITIALIZE: type(", SOLVER%N_PROJECT_COUNT, ", ", SOLVER%N_BEFORE_SMOOTH_STEP, &
    !     ", ", SOLVER%N_AFTER_SMOOTH_STEP, ")"
  END SUBROUTINE AMG_SOLVER_INITIALIZE

  ! free memory used by the solver
  SUBROUTINE AMG_SOLVER_DESTROY(SOLVER)
    TYPE(AMG_SOLVER) SOLVER

    INTEGER I
    DO I=1,SOLVER%N_MAX_PROJECT_COUNT-1
       CALL SPARSITY_PATTERN_DEALLOCATE(SOLVER%LEFT_PROJECT_PATTERN(I)%PTR)
       CALL SPARSITY_PATTERN_DEALLOCATE(SOLVER%RIGHT_PROJECT_PATTERN(I)%PTR)
       CALL SPARSITY_PATTERN_DEALLOCATE(SOLVER%PROJECTED_PATTERN(I+1)%PTR)
       CALL SPARSE_MATRIX_DEALLOCATE(SOLVER%LEFT_PROJECT_MATRIX(I)%PTR)
       CALL SPARSE_MATRIX_DEALLOCATE(SOLVER%RIGHT_PROJECT_MATRIX(I)%PTR)
       CALL SPARSE_MATRIX_DEALLOCATE(SOLVER%PROJECTED_MATRIX(I+1)%PTR)
       IF (ASSOCIATED(SOLVER%PROJECTED_SOLUTION(I+1)%PTR)) THEN
          DEALLOCATE(SOLVER%PROJECTED_SOLUTION(I+1)%PTR)
       END IF
       IF (ASSOCIATED(SOLVER%PROJECTED_RESIDUAL(I+1)%PTR)) THEN
          DEALLOCATE(SOLVER%PROJECTED_RESIDUAL(I+1)%PTR)
       END IF
    END DO
    DEALLOCATE(SOLVER%LEFT_PROJECT_PATTERN)
    DEALLOCATE(SOLVER%RIGHT_PROJECT_PATTERN)
    DEALLOCATE(SOLVER%PROJECTED_PATTERN)
    DEALLOCATE(SOLVER%LEFT_PROJECT_MATRIX)
    DEALLOCATE(SOLVER%RIGHT_PROJECT_MATRIX)
    DEALLOCATE(SOLVER%PROJECTED_MATRIX)
    DEALLOCATE(SOLVER%PROJECTED_SOLUTION)
    DEALLOCATE(SOLVER%PROJECTED_RESIDUAL)
    IF (ASSOCIATED(SOLVER%MAX_PROJECTED_MATRIX)) THEN
       DEALLOCATE(SOLVER%MAX_PROJECTED_MATRIX)
    END IF
  END SUBROUTINE AMG_SOLVER_DESTROY

  ! construct the project matrix for the solver, only according its sparsity pattern
  SUBROUTINE AMG_SOLVER_SET_PATTERN(SOLVER, PATTERN)
    TYPE(AMG_SOLVER), INTENT(INOUT)::SOLVER
    TYPE(SPARSITY_PATTERN), TARGET, INTENT(IN)::PATTERN

    INTEGER::I, J, K
    TYPE(SPARSITY_PATTERN)::P

    J = PATTERN%N_ROW
    K = PATTERN%N_COLUMN
    IF (J /= K) THEN
       PRINT *, "Error: in AMG_SOLVER_SET_PATTERN, the sparsity pattern must be square"
       READ *
    END IF
    SOLVER%PATTERN=>PATTERN
    SOLVER%PROJECTED_PATTERN(1)%PTR=>PATTERN
    DO I=2,SOLVER%N_MAX_PROJECT_COUNT
       J = SOLVER%PROJECTED_PATTERN(I-1)%PTR%N_ROW
       K = SOLVER%PROJECTED_PATTERN(I-1)%PTR%N_NONZERO
       IF (K == J) THEN ! the matrix is diagonal
          SOLVER%MAX_PROJECTED_MATRIX_TYPE = 0
          EXIT
       END IF
       IF ((REAL(K)/(REAL(J)*REAL(J)) >= 0.2) .OR. (J <= 20)) THEN ! the matrix is not sparse enough or the rank is less enough
          SOLVER%MAX_PROJECTED_MATRIX_TYPE = 1
          IF (ASSOCIATED(SOLVER%MAX_PROJECTED_MATRIX)) THEN
             DEALLOCATE(SOLVER%MAX_PROJECTED_MATRIX)
          END IF
          ALLOCATE(SOLVER%MAX_PROJECTED_MATRIX(1:J,1:J))
          EXIT
       END IF
       CALL AMG_SOLVER_PROJECTION(SOLVER%PROJECTED_PATTERN(I-1)%PTR, SOLVER%LEFT_PROJECT_PATTERN(I-1)%PTR, &
            SOLVER%LEFT_PROJECT_MATRIX(I-1)%PTR)
       CALL SPARSE_MATRIX_TRANSPOSE(SOLVER%LEFT_PROJECT_MATRIX(I-1)%PTR, SOLVER%RIGHT_PROJECT_MATRIX(I-1)%PTR, &
            SOLVER%RIGHT_PROJECT_PATTERN(I-1)%PTR)
       CALL SPARSITY_PATTERN_MULTIPLE(SOLVER%LEFT_PROJECT_PATTERN(I-1)%PTR, SOLVER%PROJECTED_PATTERN(I-1)%PTR, P)
       CALL SPARSITY_PATTERN_MULTIPLE(P, SOLVER%RIGHT_PROJECT_PATTERN(I-1)%PTR, SOLVER%PROJECTED_PATTERN(I)%PTR)
       IF (ASSOCIATED(SOLVER%PROJECTED_SOLUTION(I)%PTR)) THEN
          DEALLOCATE(SOLVER%PROJECTED_SOLUTION(I)%PTR)
       END IF
       IF (ASSOCIATED(SOLVER%PROJECTED_SOLUTION(I)%PTR)) THEN
          DEALLOCATE(SOLVER%PROJECTED_SOLUTION(I)%PTR)
       END IF
       ALLOCATE(SOLVER%PROJECTED_SOLUTION(I)%PTR(1:SOLVER%PROJECTED_PATTERN(I)%PTR%N_COLUMN))
       IF (ASSOCIATED(SOLVER%PROJECTED_RESIDUAL(I)%PTR)) THEN
          DEALLOCATE(SOLVER%PROJECTED_RESIDUAL(I)%PTR)
       END IF
       ALLOCATE(SOLVER%PROJECTED_RESIDUAL(I)%PTR(1:SOLVER%PROJECTED_PATTERN(I)%PTR%N_COLUMN))
    END DO
    SOLVER%N_PROJECT_COUNT = I-1
    CALL SPARSITY_PATTERN_DESTROY(P)
  END SUBROUTINE AMG_SOLVER_SET_PATTERN

  ! construct the projected matrix
  SUBROUTINE AMG_SOLVER_SET_MATRIX(SOLVER, MATRIX)
    TYPE(AMG_SOLVER), INTENT(INOUT)::SOLVER
    TYPE(SPARSE_MATRIX), TARGET, INTENT(IN)::MATRIX

    INTEGER::I
    TYPE(SPARSITY_PATTERN)::P
    TYPE(SPARSE_MATRIX)::M

    IF (.NOT. ASSOCIATED(MATRIX%PATTERN, SOLVER%PATTERN)) THEN
       CALL AMG_SOLVER_SET_PATTERN(SOLVER, MATRIX%PATTERN)
    END IF

    SOLVER%MATRIX=>MATRIX
    SOLVER%PROJECTED_MATRIX(1)%PTR=>MATRIX
    DO I=2,SOLVER%N_PROJECT_COUNT
       CALL SPARSE_MATRIX_INITIALIZE(SOLVER%PROJECTED_MATRIX(I)%PTR, SOLVER%PROJECTED_PATTERN(I)%PTR)
       CALL SPARSITY_PATTERN_MULTIPLE(SOLVER%LEFT_PROJECT_PATTERN(I-1)%PTR, SOLVER%PROJECTED_PATTERN(I-1)%PTR, P)
       CALL SPARSE_MATRIX_INITIALIZE(M, P)
       CALL SPARSE_MATRIX_MULTIPLE(SOLVER%LEFT_PROJECT_MATRIX(I-1)%PTR, SOLVER%PROJECTED_MATRIX(I-1)%PTR, M)
       CALL SPARSE_MATRIX_MULTIPLE(M, SOLVER%RIGHT_PROJECT_MATRIX(I-1)%PTR, SOLVER%PROJECTED_MATRIX(I)%PTR)
    END DO
    IF (SOLVER%MAX_PROJECTED_MATRIX_TYPE == 1) THEN
       CALL SPARSE_MATRIX_FULL(SOLVER%PROJECTED_MATRIX(SOLVER%N_PROJECT_COUNT)%PTR, SOLVER%MAX_PROJECTED_MATRIX)
    END IF
    CALL SPARSE_MATRIX_DESTROY(M)
    CALL SPARSITY_PATTERN_DESTROY(P)
  END SUBROUTINE AMG_SOLVER_SET_MATRIX

  ! implementation of the projection
  SUBROUTINE AMG_SOLVER_PROJECTION(P, P1, M1)
    TYPE(SPARSE_MATRIX), INTENT(INOUT)::M1
    TYPE(SPARSITY_PATTERN), INTENT(IN)::P
    TYPE(SPARSITY_PATTERN), INTENT(INOUT)::P1

    INTEGER::I, J, K, L, N
    INTEGER::N_MAX_ROW_LENGTH
    INTEGER, DIMENSION(1:P%N_ROW)::ROW_INDEX
    INTEGER, DIMENSION(1:P%N_COLUMN)::COLUMN_COUNTER

    CALL SPARSE_MATRIX_DESTROY(M1)
    CALL SPARSITY_PATTERN_DESTROY(P1)

    COLUMN_COUNTER = 0
    K = 0
    L = 0
    N_MAX_ROW_LENGTH = 0
    DO I=1,P%N_ROW
       IF (COLUMN_COUNTER(I) == 0) THEN
          K = K+1
          ROW_INDEX(K) = I
          DO J=P%ROW_START(I),P%ROW_START(I+1)-1
             N = P%COLUMN_INDEX(J)
             COLUMN_COUNTER(N) = COLUMN_COUNTER(N) + 1
          END DO
          L = L + P%ROW_START(I+1) - P%ROW_START(I)
          N_MAX_ROW_LENGTH = MAX(N_MAX_ROW_LENGTH, P%ROW_START(I+1) - P%ROW_START(I))
       END IF
    END DO

    ALLOCATE(P1%ROW_START(1:K+1))
    ALLOCATE(P1%COLUMN_INDEX(1:L))
    P1%N_ROW = K
    P1%N_COLUMN = P%N_COLUMN
    P1%N_NONZERO = L
    P1%N_MAX_ROW_LENGTH = N_MAX_ROW_LENGTH
    P1%N_MAX_VEC_LENGTH = L
    P1%IS_COMPRESSED = .TRUE.
    CALL SPARSE_MATRIX_INITIALIZE(M1, P1)
    L = 1
    DO K=1,P1%N_ROW
       I = ROW_INDEX(K)
       P1%ROW_START(K) = L
       DO J=P%ROW_START(I),P%ROW_START(I+1)-1
          N = P%COLUMN_INDEX(J)
          P1%COLUMN_INDEX(L) = N
          M1%MATRIX_ENTRY(L) = 1.0E0/REAL(COLUMN_COUNTER(N))
          L = L+1
       END DO
    END DO
    P1%ROW_START(K) = L
  END SUBROUTINE AMG_SOLVER_PROJECTION

  ! main solve engine
  SUBROUTINE AMG_SOLVER_SOLVE(SOLVER, SOLUTION, RHS)
    TYPE(AMG_SOLVER), INTENT(INOUT)::SOLVER
    REAL(dp), DIMENSION(:), TARGET, INTENT(INOUT)::SOLUTION
    REAL(dp), DIMENSION(:), TARGET, INTENT(INOUT)::RHS

    INTEGER::I, J
    REAL(dp)::ERROR, A
    TYPE(VECTOR_POINTER),DIMENSION(1:SOLVER%N_PROJECT_COUNT)::TEMP

    IF (SIZE(RHS) .NE. SIZE(SOLUTION)) THEN
      PRINT *, "IN AMG_SOLVER_SOLVE: THE DIMENSION OF THE SOLUTION AND RHS IS NOT EQUAL";
       READ *
    ENDIF 
    ERROR = MAXVAL(ABS(RHS));
    A = ERROR
    IF (ERROR/A <= REAL(SOLVER%PATTERN%N_ROW) * SOLVER%TOLERANCE) THEN
       SOLUTION = 0.0E0
       RETURN
    END IF
    SOLVER%PROJECTED_SOLUTION(1)%PTR => SOLUTION
    SOLVER%PROJECTED_RESIDUAL(1)%PTR => RHS
    DO I=1,SOLVER%N_PROJECT_COUNT-1
       ALLOCATE(TEMP(I)%PTR(1:SOLVER%PROJECTED_PATTERN(I)%PTR%N_COLUMN))
    END DO
    CALL SPARSE_MATRIX_VECTOR_MULTIPLE(SOLVER%MATRIX, SOLVER%PROJECTED_SOLUTION(1)%PTR, TEMP(1)%PTR)
    
    TEMP(1)%PTR = SOLVER%PROJECTED_RESIDUAL(1)%PTR - TEMP(1)%PTR
    ERROR = MAXVAL(ABS(TEMP(1)%PTR))
    IF (ERROR/A <= REAL(SOLVER%PATTERN%N_ROW) * SOLVER%TOLERANCE) THEN
       DO I=1,SOLVER%N_PROJECT_COUNT-1
          DEALLOCATE(TEMP(I)%PTR)
       END DO
       RETURN
    END IF
    DO
       DO I=1,SOLVER%N_PROJECT_COUNT-1
          CALL SPARSE_MATRIX_GAUSS_SIDEL(SOLVER%PROJECTED_MATRIX(I)%PTR, & 
                SOLVER%PROJECTED_SOLUTION(I)%PTR, &
                SOLVER%PROJECTED_RESIDUAL(I)%PTR, SOLVER%N_BEFORE_SMOOTH_STEP)
          TEMP(I)%PTR = SOLVER%PROJECTED_RESIDUAL(I)%PTR
          CALL SPARSE_MATRIX_VECTOR_MULT_PS(SOLVER%PROJECTED_MATRIX(I)%PTR, &
                          SOLVER%PROJECTED_SOLUTION(I)%PTR, -1.d0, TEMP(I)%PTR)
          CALL SPARSE_MATRIX_VECTOR_MULTIPLE(SOLVER%LEFT_PROJECT_MATRIX(I)%PTR, &
                                TEMP(I)%PTR, SOLVER%PROJECTED_RESIDUAL(I+1)%PTR)
          SOLVER%PROJECTED_SOLUTION(I+1)%PTR = 0.0E0
       END DO

       I = SOLVER%N_PROJECT_COUNT
       IF (SOLVER%MAX_PROJECTED_MATRIX_TYPE == 0) THEN
          DO J=1,SOLVER%PROJECTED_MATRIX(I)%PTR%PATTERN%N_ROW
             SOLVER%PROJECTED_SOLUTION(I)%PTR(J) = SOLVER%PROJECTED_SOLUTION(I)%PTR(J) / &
                  SOLVER%PROJECTED_MATRIX(I)%PTR%MATRIX_ENTRY(J)
          END DO
       ELSE
          CALL AMG_SOLVER_GAUSS_ELIMINATION(SOLVER%MAX_PROJECTED_MATRIX, SOLVER%PROJECTED_SOLUTION(I)%PTR, &
               SOLVER%PROJECTED_RESIDUAL(I)%PTR, SOLVER%PROJECTED_MATRIX(I)%PTR%PATTERN%N_ROW)
       END IF

       DO I=SOLVER%N_PROJECT_COUNT-1,1,-1
          CALL SPARSE_MATRIX_VECTOR_MULT_P(SOLVER%RIGHT_PROJECT_MATRIX(I)%PTR, SOLVER%PROJECTED_SOLUTION(I+1)%PTR, &
               SOLVER%PROJECTED_SOLUTION(I)%PTR)
          CALL SPARSE_MATRIX_GAUSS_SIDEL(SOLVER%PROJECTED_MATRIX(I)%PTR, SOLVER%PROJECTED_SOLUTION(I)%PTR, &
               SOLVER%PROJECTED_RESIDUAL(I)%PTR, SOLVER%N_AFTER_SMOOTH_STEP)
       END DO

       CALL SPARSE_MATRIX_VECTOR_MULTIPLE(SOLVER%MATRIX, SOLVER%PROJECTED_SOLUTION(1)%PTR, TEMP(1)%PTR)

       TEMP(1)%PTR = SOLVER%PROJECTED_RESIDUAL(1)%PTR - TEMP(1)%PTR
       ERROR = MAXVAL(ABS(TEMP(1)%PTR))
       print *, ERROR, A,ERROR/A, REAL(SOLVER%PATTERN%N_ROW) * SOLVER%TOLERANCE
       IF (ERROR/A <= REAL(SOLVER%PATTERN%N_ROW) * SOLVER%TOLERANCE) THEN
          SOLUTION = SOLVER%PROJECTED_SOLUTION(1)%PTR
          DO I=1,SOLVER%N_PROJECT_COUNT-1
             DEALLOCATE(TEMP(I)%PTR)
          END DO
          RETURN
       END IF
    END DO
  END SUBROUTINE AMG_SOLVER_SOLVE

  ! standard Gauss elimination method to solve a small linear system
  SUBROUTINE AMG_SOLVER_GAUSS_ELIMINATION(MATRIX, X, R, N)
    INTEGER, INTENT(IN)::N
    REAL(dp), DIMENSION(N,N), INTENT(IN)::MATRIX
    REAL(dp), DIMENSION(N), INTENT(OUT)::X
    REAL(dp), DIMENSION(N), INTENT(IN)::R

    INTEGER ::I, J, K
    REAL(dp)::A, B
    REAL(dp), DIMENSION(1:N,1:N+1)::M
    REAL(dp), DIMENSION(1:N+1)::TEMP

    M(1:N,1:N) = MATRIX(1:N,1:N)
    M(1:N,N+1) = R(1:N)
    DO I=1,N-1
       A = ABS(M(I,I))
       K = I
       DO J=I+1,N
          B = ABS(M(J,I))
          IF ( B > A) THEN
             A = B;  K = J
          END IF
       END DO! the max abs element on col I below (I,I) diagonal with value A and row index K
       IF (A <= 1.0E-16) THEN
          PRINT *, "Error: in AMG_SOLVER_GAUSS_ELIMINATION, the matrix is singular"
          READ *
       END IF
       IF (K /= I) THEN ! swap two rows so that the new row I has the max abs val.
          TEMP(I:N+1) = M(I,I:N+1)
          M(I,I:N+1) = M(K,I:N+1)
          M(K,I:N+1) = TEMP(I:N+1)
       END IF
       DO J=I+1,N
          A = M(J,I)/M(I,I)
          M(J,I:N+1) = M(J,I:N+1) - A*M(I,I:N+1)
       END DO
    END DO
    DO I=N,1,-1
       DO J=I+1,N
          M(I,N+1) = M(I,N+1) - M(I,J)*X(J)
       END DO
       X(I) = M(I,N+1)/M(I,I)
    END DO
    !print *, "GE error=", maxval( abs( matmul(matrix(1:N,1:N),X(1:N))-R)) / maxval(abs(R(1:N)))
    !read *
  END SUBROUTINE AMG_SOLVER_GAUSS_ELIMINATION

END MODULE AMG_SOLVER_MODULE

! end of file

